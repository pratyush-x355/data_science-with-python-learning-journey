diff --git a/.DS_Store b/.DS_Store
new file mode 100644
index 0000000..a5298d5
Binary files /dev/null and b/.DS_Store differ
diff --git a/datetime.ipynb b/datetime.ipynb
index 35806b0..ccefefe 100644
--- a/datetime.ipynb
+++ b/datetime.ipynb
@@ -20,6 +20,7 @@
   },
   {
    "cell_type": "code",
+<<<<<<< HEAD
    "execution_count": 14,
    "metadata": {},
    "outputs": [
@@ -51,6 +52,20 @@
       "tzinfo <class 'datetime.tzinfo'>\n",
       "['tzname', 'utcoffset', 'dst', 'fromutc']\n",
       "--------------------------------------------------------------------------------------------------\n"
+=======
+   "execution_count": 1,
+   "metadata": {},
+   "outputs": [
+    {
+     "ename": "NameError",
+     "evalue": "name 'inspect' is not defined",
+     "output_type": "error",
+     "traceback": [
+      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
+      "\u001b[0;31mNameError\u001b[0m                                 Traceback (most recent call last)",
+      "\u001b[1;32m/Users/pkt/investment_project/python_learning/python_learning/datetime.ipynb Cell 3\u001b[0m line \u001b[0;36m1\n\u001b[0;32m----> <a href='vscode-notebook-cell:/Users/pkt/investment_project/python_learning/python_learning/datetime.ipynb#W2sZmlsZQ%3D%3D?line=0'>1</a>\u001b[0m classes \u001b[39m=\u001b[39m inspect\u001b[39m.\u001b[39mgetmembers(dt, inspect\u001b[39m.\u001b[39misclass)\n\u001b[1;32m      <a href='vscode-notebook-cell:/Users/pkt/investment_project/python_learning/python_learning/datetime.ipynb#W2sZmlsZQ%3D%3D?line=1'>2</a>\u001b[0m dash_line \u001b[39m=\u001b[39m \u001b[39m'\u001b[39m\u001b[39m-\u001b[39m\u001b[39m'\u001b[39m\u001b[39m.\u001b[39mjoin(\u001b[39m\"\u001b[39m\u001b[39m\"\u001b[39m \u001b[39mfor\u001b[39;00m i \u001b[39min\u001b[39;00m \u001b[39mrange\u001b[39m(\u001b[39m1\u001b[39m,\u001b[39m100\u001b[39m))\n\u001b[1;32m      <a href='vscode-notebook-cell:/Users/pkt/investment_project/python_learning/python_learning/datetime.ipynb#W2sZmlsZQ%3D%3D?line=2'>3</a>\u001b[0m chunk_size \u001b[39m=\u001b[39m \u001b[39m5\u001b[39m\n",
+      "\u001b[0;31mNameError\u001b[0m: name 'inspect' is not defined"
+>>>>>>> c1b8b2d (changes from macbook)
      ]
     }
    ],
@@ -238,7 +253,11 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
+<<<<<<< HEAD
    "version": "3.10.12"
+=======
+   "version": "3.11.4"
+>>>>>>> c1b8b2d (changes from macbook)
   },
   "orig_nbformat": 4
  },
diff --git a/oop/item.py b/oop/item.py
new file mode 100644
index 0000000..2173f34
--- /dev/null
+++ b/oop/item.py
@@ -0,0 +1,78 @@
+import pandas as pd
+
+class Item:
+    pay_rate = 0.8 # class level attribute
+    all = []
+    item_dict = {
+        "name": ["Phone", "Laptop", "Cable", "Mouse", "Keyboard"],
+        "price": [100, 1000, 10, 50, 75],
+        "quantity": [1,3,5,5,5]
+    }
+    # Any method called in a class take atleast one paramter that is self
+    # Magic methods: constructors
+    def __init__(self, name: str, price: float, quantity = 0) -> None:
+        # Run validation to the received arguments
+        assert price >= 0, f"price {price} is not greater than or equal to zero"
+        assert quantity >= 0, f"quantity {quantity} is not greater than or equal to zero"
+        # Assign values to the attributes/self object
+        # First we will assign the value to name
+        # self.name = name
+        # Second, we want to make 'name' readable by using property, so modidied the actual name to '_name'
+        # self._name = name
+        # Lastly, make name private so that it won't be accesible outside class, use __name
+        self.__name = name
+        self.price = price
+        self.quantity = quantity
+        # Executable instances
+        Item.all.append(self)
+    
+    @property
+    def name(self):
+        # property decirator, name is not a method but a readable attribute
+        return self.__name
+    
+    @name.setter
+    def name(self, value):
+        if len(value) > 10:
+            print("name is too long")
+        else:
+            self.__name = value
+    
+    def get_total_price(self):
+       return self.quantity * self.price
+    
+    def get_discounted_price(self):
+        return self.price*self.pay_rate
+    
+    @classmethod
+    def instantaliate_from_dataframe(cls):
+        df = pd.DataFrame(Item.item_dict)
+        dict_list = []
+        # Iterate over each row in the DataFrame
+        for index, row in df.iterrows():
+            row_dict = row.to_dict()   # Convert the row to a dictionary
+            dict_list.append(row_dict) # Append the dictionary to the list
+        
+        for item in dict_list:
+            Item(
+                name = item.get("name"),
+                price = item.get("price"),
+                quantity = item.get("quantity")
+            )
+    
+    @staticmethod
+    def is_integer(num):
+        if isinstance(num, float):
+            return num.is_integer()
+        elif isinstance(num, int):
+            return True
+        else:
+            return False
+
+    def __repr__(self) -> str:
+        return f"{self.__class__.__name__}({self.name},{self.price},{self.quantity})"
+    
+    # this was used just to see how a property decorator works
+    # @property
+    # def read_only_name(self):
+    #    return "AAA"
\ No newline at end of file
diff --git a/oop/main.py b/oop/main.py
new file mode 100644
index 0000000..4ed4c2e
--- /dev/null
+++ b/oop/main.py
@@ -0,0 +1,19 @@
+from item import Item
+from phone import Phone
+import pandas as pd
+
+# More about getter and setters
+# How to restict user from editing few read only attributes
+# How to use "encapsulation"
+# Item.instantaliate_from_dataframe()
+# print(Item.all)
+item1 = Item("myItem", 500, 5)
+print(item1.name)
+
+item1.name = "otherItem" #execute the setter
+
+print(item1.name) # where ever you will use name it will execute proporty decorator
+
+item1.price = -9000
+
+print(item1.price)
\ No newline at end of file
diff --git a/oop/oop.ipynb b/oop/oop.ipynb
new file mode 100644
index 0000000..1f36352
--- /dev/null
+++ b/oop/oop.ipynb
@@ -0,0 +1,758 @@
+{
+ "cells": [
+  {
+   "cell_type": "code",
+   "execution_count": 3,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "class Item:\n",
+    "    # Any method called in a class take atleast one paramter that is self\n",
+    "    # Magic methods: constructors\n",
+    "    def __init__(self, name) -> None:\n",
+    "        print(f\"A instance created:{name}\")\n",
+    "    \n",
+    "    def get_total_price(self, x, y):\n",
+    "        return x*y"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 5,
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "A instance created:Phone\n",
+      "500\n",
+      "A instance created:Laptop\n",
+      "2000\n"
+     ]
+    }
+   ],
+   "source": [
+    "item1 = Item(\"Phone\")\n",
+    "item1.name = \"Phone\"\n",
+    "item1.price = 100\n",
+    "item1.quantity = 5\n",
+    "print(item1.get_total_price(item1.price, item1.quantity))\n",
+    "\n",
+    "item2 = Item(\"Laptop\")\n",
+    "item2.name = \"Laptop\"\n",
+    "item2.price = 1000\n",
+    "item2.quantity = 2\n",
+    "print(item2.get_total_price(item2.price, item2.quantity))"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 11,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "class Item:\n",
+    "    # Any method called in a class take atleast one paramter that is self\n",
+    "    # Magic methods: constructors\n",
+    "    def __init__(self, name, price, quantity = 0) -> None:\n",
+    "        self.name = name\n",
+    "        self.price = price\n",
+    "        self.quantity = quantity\n",
+    "    \n",
+    "    def get_total_price(self):\n",
+    "        # return x*y\n",
+    "        # instead of passing two extra paramters we can use the attributes of self itself\n",
+    "        # Self is itself passed as an argument\n",
+    "        # We can directly use the attributes to get total price\n",
+    "       return self.quantity * self.price"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 15,
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "2000\n",
+      "5000\n"
+     ]
+    }
+   ],
+   "source": [
+    "item1 = Item(\"Phone\", 500)\n",
+    "item1.quantity = 4\n",
+    "print(item1.get_total_price())\n",
+    "\n",
+    "item2 = Item(\"Laptop\", 1000,5)\n",
+    "print(item2.get_total_price())\n",
+    "\n",
+    "item2.is_numpad = False"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "##### Learn more about handling of assertion error"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 28,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "# How to validate the datatype of all class attributes\n",
+    "class Item:\n",
+    "    # Any method called in a class take atleast one paramter that is self\n",
+    "    # Magic methods: constructors\n",
+    "    def __init__(self, name: str, price: float, quantity = 0) -> None:\n",
+    "        # Run validation to the received arguments\n",
+    "        assert price >= 0, f\"price {price} is not greater than or equal to zero\"\n",
+    "        assert quantity >= 0, f\"quantity {quantity} is not greater than or equal to zero\"\n",
+    "        # Assign values to the attributes/self object\n",
+    "        self.name = name\n",
+    "        self.price = price\n",
+    "        self.quantity = quantity\n",
+    "    \n",
+    "    def get_total_price(self):\n",
+    "        # return x*y\n",
+    "        # instead of passing two extra paramters we can use the attributes of self itself\n",
+    "        # Self is itself passed as an argument\n",
+    "        # We can directly use the attributes to get total price\n",
+    "       return self.quantity * self.price"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 31,
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "400\n",
+      "5000\n"
+     ]
+    }
+   ],
+   "source": [
+    "item1 = Item(\"Phone\", 100)\n",
+    "item1.quantity = 4\n",
+    "print(item1.get_total_price())\n",
+    "\n",
+    "item2 = Item(\"Laptop\", 1000, 5)\n",
+    "print(item2.get_total_price())\n",
+    "\n",
+    "item2.is_numpad = False"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "#### Class attributes\n",
+    "##### Class attributes can be accessed by class name or self, representing of an instance while calling attributes or methods"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 1,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "# Sharing the attributes across all the instances\n",
+    "# like magic function/methods there is amgic attributes too in a class\n",
+    "# we will use __dict__ to see how to works\n",
+    "# How to validate the datatype of all class attributes\n",
+    "class Item:\n",
+    "    pay_rate = 0.8 # class level attribute\n",
+    "    # Any method called in a class take atleast one paramter that is self\n",
+    "    # Magic methods: constructors\n",
+    "    def __init__(self, name: str, price: float, quantity = 0) -> None:\n",
+    "        # Run validation to the received arguments\n",
+    "        assert price >= 0, f\"price {price} is not greater than or equal to zero\"\n",
+    "        assert quantity >= 0, f\"quantity {quantity} is not greater than or equal to zero\"\n",
+    "        # Assign values to the attributes/self object\n",
+    "        self.name = name\n",
+    "        self.price = price\n",
+    "        self.quantity = quantity\n",
+    "    \n",
+    "    def get_total_price(self):\n",
+    "       return self.quantity * self.price\n",
+    "    \n",
+    "    def get_discounted_price(self):\n",
+    "        # only call class attribute with class name if you don't want to change it in future\n",
+    "        # return self.price*Item.pay_rate\n",
+    "        # Best practice is to call with self if the class level attribute can be modified for each instance\n",
+    "        return self.price*self.pay_rate"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 2,
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "{'__module__': '__main__', 'pay_rate': 0.8, '__init__': <function Item.__init__ at 0x1106216c0>, 'get_total_price': <function Item.get_total_price at 0x1106215a0>, 'get_discounted_price': <function Item.get_discounted_price at 0x110621a20>, '__dict__': <attribute '__dict__' of 'Item' objects>, '__weakref__': <attribute '__weakref__' of 'Item' objects>, '__doc__': None}\n",
+      "\n",
+      "{'name': 'Phone', 'price': 100, 'quantity': 4}\n"
+     ]
+    }
+   ],
+   "source": [
+    "item1 = Item(\"Phone\", 100, 4)\n",
+    "print(Item.__dict__)\n",
+    "print(\"\")\n",
+    "print(item1.__dict__)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 42,
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "700.0\n"
+     ]
+    }
+   ],
+   "source": [
+    "item1 = Item(\"Phone\", 100, 4)\n",
+    "#print(item1.get_discounted_price())\n",
+    "\n",
+    "item2 = Item(\"Laptop\", 1000, 5)\n",
+    "item2.pay_rate = 0.7\n",
+    "print(item2.get_discounted_price())"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 43,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "item1 = Item(\"Phone\", 100, 1)\n",
+    "item2 = Item(\"Laptop\", 1000, 3)\n",
+    "item3 = Item(\"Cable\", 10, 5)\n",
+    "item4 = Item(\"Mouse\", 50, 5)\n",
+    "item5 = Item(\"Keyboard\", 75, 5)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "#### How to keep track of all the instances created for a class\n",
+    "##### use of magic method __repr__"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 4,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "class Item:\n",
+    "    pay_rate = 0.8 # class level attribute\n",
+    "    all = []\n",
+    "    # Any method called in a class take atleast one paramter that is self\n",
+    "    # Magic methods: constructors\n",
+    "    def __init__(self, name: str, price: float, quantity = 0) -> None:\n",
+    "        # Run validation to the received arguments\n",
+    "        assert price >= 0, f\"price {price} is not greater than or equal to zero\"\n",
+    "        assert quantity >= 0, f\"quantity {quantity} is not greater than or equal to zero\"\n",
+    "        # Assign values to the attributes/self object\n",
+    "        self.name = name\n",
+    "        self.price = price\n",
+    "        self.quantity = quantity\n",
+    "        # Executable instances\n",
+    "        Item.all.append(self)\n",
+    "    \n",
+    "    def get_total_price(self):\n",
+    "       return self.quantity * self.price\n",
+    "    \n",
+    "    def get_discounted_price(self):\n",
+    "        return self.price*self.pay_rate\n",
+    "    \n",
+    "    def __repr__(self) -> str:\n",
+    "        return f\"Item({self.name},{self.price},{self.quantity})\""
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 5,
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "[Item(Phone,100,1), Item(Laptop,1000,3), Item(Cable,10,5), Item(Mouse,50,5), Item(Keyboard,75,5)]\n"
+     ]
+    }
+   ],
+   "source": [
+    "item1 = Item(\"Phone\", 100, 1)\n",
+    "item2 = Item(\"Laptop\", 1000, 3)\n",
+    "item3 = Item(\"Cable\", 10, 5)\n",
+    "item4 = Item(\"Mouse\", 50, 5)\n",
+    "item5 = Item(\"Keyboard\", 75, 5)\n",
+    "print(Item.all)"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "#### introduction to class method"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 54,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "import pandas as pd"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 61,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "class Item:\n",
+    "    pay_rate = 0.8 # class level attribute\n",
+    "    all = []\n",
+    "    item_dict = {\n",
+    "        \"name\": [\"Phone\", \"Laptop\", \"Cable\", \"Mouse\", \"Keyboard\"],\n",
+    "        \"price\": [100, 1000, 10, 50, 75],\n",
+    "        \"quantity\": [1,3,5,5,5]\n",
+    "    }\n",
+    "    # Any method called in a class take atleast one paramter that is self\n",
+    "    # Magic methods: constructors\n",
+    "    def __init__(self, name: str, price: float, quantity = 0) -> None:\n",
+    "        # Run validation to the received arguments\n",
+    "        assert price >= 0, f\"price {price} is not greater than or equal to zero\"\n",
+    "        assert quantity >= 0, f\"quantity {quantity} is not greater than or equal to zero\"\n",
+    "        # Assign values to the attributes/self object\n",
+    "        self.name = name\n",
+    "        self.price = price\n",
+    "        self.quantity = quantity\n",
+    "        # Executable instances\n",
+    "        Item.all.append(self)\n",
+    "    \n",
+    "    def get_total_price(self):\n",
+    "       return self.quantity * self.price\n",
+    "    \n",
+    "    def get_discounted_price(self):\n",
+    "        return self.price*self.pay_rate\n",
+    "    \n",
+    "    @classmethod\n",
+    "    def instantaliate_from_dataframe(cls):\n",
+    "        df = pd.DataFrame(Item.item_dict)\n",
+    "        dict_list = []\n",
+    "        # Iterate over each row in the DataFrame\n",
+    "        for index, row in df.iterrows():\n",
+    "            # Convert the row to a dictionary\n",
+    "            row_dict = row.to_dict()\n",
+    "            # Append the dictionary to the list\n",
+    "            dict_list.append(row_dict)\n",
+    "        \n",
+    "        for item in dict_list:\n",
+    "            Item(\n",
+    "                name = item.get(\"name\"),\n",
+    "                price = item.get(\"price\"),\n",
+    "                quantity = item.get(\"quantity\")\n",
+    "            )\n",
+    "     \n",
+    "    def __repr__(self) -> str:\n",
+    "        return f\"Item({self.name},{self.price},{self.quantity})\""
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 62,
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "[Item(Phone,100,1),\n",
+       " Item(Laptop,1000,3),\n",
+       " Item(Cable,10,5),\n",
+       " Item(Mouse,50,5),\n",
+       " Item(Keyboard,75,5)]"
+      ]
+     },
+     "execution_count": 62,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "Item.instantaliate_from_dataframe()\n",
+    "Item.all"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "##### Difference between class and static method"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 68,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "class Item:\n",
+    "    pay_rate = 0.8 # class level attribute\n",
+    "    all = []\n",
+    "    item_dict = {\n",
+    "        \"name\": [\"Phone\", \"Laptop\", \"Cable\", \"Mouse\", \"Keyboard\"],\n",
+    "        \"price\": [100, 1000, 10, 50, 75],\n",
+    "        \"quantity\": [1,3,5,5,5]\n",
+    "    }\n",
+    "    # Any method called in a class take atleast one paramter that is self\n",
+    "    # Magic methods: constructors\n",
+    "    def __init__(self, name: str, price: float, quantity = 0) -> None:\n",
+    "        # Run validation to the received arguments\n",
+    "        assert price >= 0, f\"price {price} is not greater than or equal to zero\"\n",
+    "        assert quantity >= 0, f\"quantity {quantity} is not greater than or equal to zero\"\n",
+    "        # Assign values to the attributes/self object\n",
+    "        self.name = name\n",
+    "        self.price = price\n",
+    "        self.quantity = quantity\n",
+    "        # Executable instances\n",
+    "        Item.all.append(self)\n",
+    "    \n",
+    "    def get_total_price(self):\n",
+    "       return self.quantity * self.price\n",
+    "    \n",
+    "    def get_discounted_price(self):\n",
+    "        return self.price*self.pay_rate\n",
+    "    \n",
+    "    @classmethod\n",
+    "    def instantaliate_from_dataframe(cls):\n",
+    "        df = pd.DataFrame(Item.item_dict)\n",
+    "        dict_list = []\n",
+    "        # Iterate over each row in the DataFrame\n",
+    "        for index, row in df.iterrows():\n",
+    "            row_dict = row.to_dict()   # Convert the row to a dictionary\n",
+    "            dict_list.append(row_dict) # Append the dictionary to the list\n",
+    "        \n",
+    "        for item in dict_list:\n",
+    "            Item(\n",
+    "                name = item.get(\"name\"),\n",
+    "                price = item.get(\"price\"),\n",
+    "                quantity = item.get(\"quantity\")\n",
+    "            )\n",
+    "    @staticmethod\n",
+    "    def is_integer(num):\n",
+    "        if isinstance(num, float):\n",
+    "            return num.is_integer()\n",
+    "        elif isinstance(num, int):\n",
+    "            return True\n",
+    "        else:\n",
+    "            return False\n",
+    "\n",
+    "    def __repr__(self) -> str:\n",
+    "        return f\"Item({self.name},{self.price},{self.quantity})\""
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 64,
+   "metadata": {},
+   "outputs": [
+    {
+     "data": {
+      "text/plain": [
+       "True"
+      ]
+     },
+     "execution_count": 64,
+     "metadata": {},
+     "output_type": "execute_result"
+    }
+   ],
+   "source": [
+    "Item.is_integer(5.0)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 67,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "class Item:\n",
+    "    @staticmethod\n",
+    "    def is_integer(num):\n",
+    "        # Class or instance object is not called first, it's like any other function outside the class\n",
+    "        # This shoud do something that is rellated to class\n",
+    "        # However, it is not unique per instance\n",
+    "        pass\n",
+    "    @classmethod\n",
+    "    def create_instance_from_dataframe(cls):\n",
+    "        # Class is itself the first object and this type of methods are not used often\n",
+    "        # This should do something that has a relationship with the class,\n",
+    "        # that are used to instantiate instances of the class\n",
+    "        pass\n",
+    "    # both static and class method can be called from instances but that is not the best practice\n",
+    "    # Call both static and class method from class level"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "#### Inheritance"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 1,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "class Item:\n",
+    "    pay_rate = 0.8 # class level attribute\n",
+    "    all = []\n",
+    "    item_dict = {\n",
+    "        \"name\": [\"Phone\", \"Laptop\", \"Cable\", \"Mouse\", \"Keyboard\"],\n",
+    "        \"price\": [100, 1000, 10, 50, 75],\n",
+    "        \"quantity\": [1,3,5,5,5]\n",
+    "    }\n",
+    "    # Any method called in a class take atleast one paramter that is self\n",
+    "    # Magic methods: constructors\n",
+    "    def __init__(self, name: str, price: float, quantity = 0) -> None:\n",
+    "        # Run validation to the received arguments\n",
+    "        assert price >= 0, f\"price {price} is not greater than or equal to zero\"\n",
+    "        assert quantity >= 0, f\"quantity {quantity} is not greater than or equal to zero\"\n",
+    "        # Assign values to the attributes/self object\n",
+    "        self.name = name\n",
+    "        self.price = price\n",
+    "        self.quantity = quantity\n",
+    "        # Executable instances\n",
+    "        Item.all.append(self)\n",
+    "    \n",
+    "    def get_total_price(self):\n",
+    "       return self.quantity * self.price\n",
+    "    \n",
+    "    def get_discounted_price(self):\n",
+    "        return self.price*self.pay_rate\n",
+    "    \n",
+    "    @classmethod\n",
+    "    def instantaliate_from_dataframe(cls):\n",
+    "        df = pd.DataFrame(Item.item_dict)\n",
+    "        dict_list = []\n",
+    "        # Iterate over each row in the DataFrame\n",
+    "        for index, row in df.iterrows():\n",
+    "            row_dict = row.to_dict()   # Convert the row to a dictionary\n",
+    "            dict_list.append(row_dict) # Append the dictionary to the list\n",
+    "        \n",
+    "        for item in dict_list:\n",
+    "            Item(\n",
+    "                name = item.get(\"name\"),\n",
+    "                price = item.get(\"price\"),\n",
+    "                quantity = item.get(\"quantity\")\n",
+    "            )\n",
+    "    @staticmethod\n",
+    "    def is_integer(num):\n",
+    "        if isinstance(num, float):\n",
+    "            return num.is_integer()\n",
+    "        elif isinstance(num, int):\n",
+    "            return True\n",
+    "        else:\n",
+    "            return False\n",
+    "\n",
+    "    def __repr__(self) -> str:\n",
+    "        return f\"Item({self.name},{self.price},{self.quantity})\"\n",
+    "    \n",
+    "class Phone(Item):\n",
+    "    all = []\n",
+    "    def __init__(self, name: str, price: float, quantity = 0, broken_phones = 0) -> None:\n",
+    "        # Run validation to the received arguments\n",
+    "        assert price >= 0, f\"price {price} is not greater than or equal to zero\"\n",
+    "        assert quantity >= 0, f\"quantity {quantity} is not greater than or equal to zero\"\n",
+    "        assert broken_phones >=0, f\"brokenphones {broken_phones} is not greater than or equal to zero\"\n",
+    "        # Assign values to the attributes/self object\n",
+    "        self.name = name\n",
+    "        self.price = price\n",
+    "        self.quantity = quantity\n",
+    "        self.broken_phone = broken_phones\n",
+    "        # Executable instances\n",
+    "        Phone.all.append(self)"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 6,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "phone1 = Phone(\"Mc1\", 500, 5, 1)\n",
+    "phone2 = Phone(\"Mc2\", 1000, 4, 1)\n",
+    "print(phone1.get_total_price())"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "##### Inheritance with calling Super().__init__ in the constructor\n",
+    "This method call the constructor of super class and inherit all the attributes and mthods called under the super constructor\n",
+    "While passing a class while creating another class, all other attributes and methods are anyway inherited. I might be wrong though"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 36,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "class Item:\n",
+    "    pay_rate = 0.8 # class level attribute\n",
+    "    all = []\n",
+    "    item_dict = {\n",
+    "        \"name\": [\"Phone\", \"Laptop\", \"Cable\", \"Mouse\", \"Keyboard\"],\n",
+    "        \"price\": [100, 1000, 10, 50, 75],\n",
+    "        \"quantity\": [1,3,5,5,5]\n",
+    "    }\n",
+    "    # Any method called in a class take atleast one paramter that is self\n",
+    "    # Magic methods: constructors\n",
+    "    def __init__(self, name: str, price: float, quantity = 0) -> None:\n",
+    "        # Run validation to the received arguments\n",
+    "        assert price >= 0, f\"price {price} is not greater than or equal to zero\"\n",
+    "        assert quantity >= 0, f\"quantity {quantity} is not greater than or equal to zero\"\n",
+    "        # Assign values to the attributes/self object\n",
+    "        self.name = name\n",
+    "        self.price = price\n",
+    "        self.quantity = quantity\n",
+    "        # Executable instances\n",
+    "        Item.all.append(self)\n",
+    "    \n",
+    "    def get_total_price(self):\n",
+    "       return self.quantity * self.price\n",
+    "    \n",
+    "    def get_discounted_price(self):\n",
+    "        return self.price*self.pay_rate\n",
+    "    \n",
+    "    @classmethod\n",
+    "    def instantaliate_from_dataframe(cls):\n",
+    "        df = pd.DataFrame(Item.item_dict)\n",
+    "        dict_list = []\n",
+    "        # Iterate over each row in the DataFrame\n",
+    "        for index, row in df.iterrows():\n",
+    "            row_dict = row.to_dict()   # Convert the row to a dictionary\n",
+    "            dict_list.append(row_dict) # Append the dictionary to the list\n",
+    "        \n",
+    "        for item in dict_list:\n",
+    "            Item(\n",
+    "                name = item.get(\"name\"),\n",
+    "                price = item.get(\"price\"),\n",
+    "                quantity = item.get(\"quantity\")\n",
+    "            )\n",
+    "    @staticmethod\n",
+    "    def is_integer(num):\n",
+    "        if isinstance(num, float):\n",
+    "            return num.is_integer()\n",
+    "        elif isinstance(num, int):\n",
+    "            return True\n",
+    "        else:\n",
+    "            return False\n",
+    "\n",
+    "    def __repr__(self) -> str:\n",
+    "        return f\"{self.__class__.__name__}({self.name},{self.price},{self.quantity})\"\n",
+    "    \n",
+    "class Phone(Item):\n",
+    "    def __init__(self, name: str, price: float, quantity = 0, broken_phones = 0) -> None:\n",
+    "        # call to super function to access to all attributes and methods\n",
+    "        # I am not sure what method we are talking about?\n",
+    "        super().__init__(\n",
+    "            name, price, quantity\n",
+    "        )\n",
+    "        # Run validation to the received arguments\n",
+    "        assert broken_phones >=0, f\"brokenphones {broken_phones} is not greater than or equal to zero\"\n",
+    "        # Assign values to the attributes/self object\n",
+    "        self.broken_phone = broken_phones"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 37,
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "2500\n"
+     ]
+    }
+   ],
+   "source": [
+    "phone1 = Phone(\"Mc1\", 500, 5, 1)\n",
+    "phone2 = Phone(\"Mc2\", 1000, 4, 1)\n",
+    "print(phone1.get_total_price())"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "##### Four key principles of large programs\n",
+    "\n",
+    "###### Encapsulation\n",
+    "###### Abstraction\n",
+    "###### Inheritance\n",
+    "###### Polymorphism"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {},
+   "outputs": [],
+   "source": []
+  }
+ ],
+ "metadata": {
+  "kernelspec": {
+   "display_name": "base",
+   "language": "python",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.10.13"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 2
+}
diff --git a/oop/phone.py b/oop/phone.py
new file mode 100644
index 0000000..e07076b
--- /dev/null
+++ b/oop/phone.py
@@ -0,0 +1,14 @@
+from item import Item
+import pandas as pd
+
+class Phone(Item):
+    def __init__(self, name: str, price: float, quantity = 0, broken_phones = 0) -> None:
+        # call to super function to access to all attributes and methods
+        # I am not sure what method we are talking about?
+        super().__init__(
+            name, price, quantity
+        )
+        # Run validation to the received arguments
+        assert broken_phones >=0, f"brokenphones {broken_phones} is not greater than or equal to zero"
+        # Assign values to the attributes/self object
+        self.broken_phone = broken_phones
\ No newline at end of file
diff --git a/pandas.ipynb b/pandas.ipynb
index 8fb271c..911dcbd 100644
--- a/pandas.ipynb
+++ b/pandas.ipynb
@@ -2,7 +2,11 @@
  "cells": [
   {
    "cell_type": "code",
+<<<<<<< HEAD
    "execution_count": 1,
+=======
+   "execution_count": 2,
+>>>>>>> c1b8b2d (changes from macbook)
    "metadata": {},
    "outputs": [
     {
@@ -15,12 +19,202 @@
    ],
    "source": [
     "import pandas as pd\n",
+<<<<<<< HEAD
+=======
+    "import inspect\n",
+>>>>>>> c1b8b2d (changes from macbook)
     "df = pd.DataFrame({'a': [1,2,3], 'b':[4,5,6]})\n",
     "print(type(df))"
    ]
   },
   {
    "cell_type": "code",
+<<<<<<< HEAD
+=======
+   "execution_count": 5,
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "ArrowDtype <class 'pandas.core.arrays.arrow.dtype.ArrowDtype'>\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "BooleanDtype <class 'pandas.core.arrays.boolean.BooleanDtype'>\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Categorical <class 'pandas.core.arrays.categorical.Categorical'>\n",
+      "['astype', 'to_list', 'set_ordered', 'as_ordered', 'as_unordered', 'set_categories', 'rename_categories', 'reorder_categories', 'add_categories', 'remove_categories']\n",
+      "['remove_unused_categories', 'map', 'memory_usage', 'isna', 'isnull', 'notna', 'notnull', 'value_counts', 'check_for_ordered', 'argsort']\n",
+      "['sort_values', 'min', 'max', 'unique', 'equals', 'describe', 'isin']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "CategoricalDtype <class 'pandas.core.dtypes.dtypes.CategoricalDtype'>\n",
+      "['type', 'validate_ordered', 'validate_categories', 'update_dtype']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "CategoricalIndex <class 'pandas.core.indexes.category.CategoricalIndex'>\n",
+      "['equals', 'reindex', 'map', 'rename_categories', 'reorder_categories', 'add_categories', 'remove_categories', 'remove_unused_categories', 'set_categories', 'as_ordered']\n",
+      "['as_unordered', 'argsort', 'tolist', 'searchsorted', 'min', 'max']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "DataFrame <class 'pandas.core.frame.DataFrame'>\n",
+      "['to_string', 'items', 'iterrows', 'itertuples', 'dot', 'to_numpy', 'to_dict', 'to_gbq', 'to_records', 'to_stata']\n",
+      "['to_feather', 'to_markdown', 'to_parquet', 'to_orc', 'to_html', 'to_xml', 'info', 'memory_usage', 'transpose', 'isetitem']\n",
+      "['query', 'eval', 'select_dtypes', 'insert', 'assign', 'align', 'set_axis', 'reindex', 'drop', 'rename']\n",
+      "['fillna', 'pop', 'replace', 'shift', 'set_index', 'reset_index', 'isna', 'isnull', 'notna', 'notnull']\n",
+      "['dropna', 'drop_duplicates', 'duplicated', 'sort_values', 'sort_index', 'value_counts', 'nlargest', 'nsmallest', 'swaplevel', 'reorder_levels']\n",
+      "['compare', 'combine', 'combine_first', 'update', 'groupby', 'pivot', 'pivot_table', 'stack', 'explode', 'unstack']\n",
+      "['melt', 'diff', 'aggregate', 'agg', 'any', 'transform', 'apply', 'applymap', 'join', 'merge']\n",
+      "['round', 'corr', 'cov', 'corrwith', 'count', 'nunique', 'idxmin', 'idxmax', 'mode', 'quantile']\n",
+      "['asfreq', 'resample', 'to_timestamp', 'to_period', 'isin', 'hist', 'boxplot', 'ffill', 'bfill', 'clip']\n",
+      "['interpolate', 'where', 'mask', 'all', 'sem', 'var', 'std', 'cummin', 'cummax', 'cumsum']\n",
+      "['cumprod', 'sum', 'prod', 'product', 'mean', 'skew', 'kurt', 'kurtosis', 'median', 'max']\n",
+      "['min', 'add', 'radd', 'sub', 'mul', 'truediv', 'floordiv', 'mod', 'pow', 'rmul']\n",
+      "['rsub', 'rtruediv', 'rfloordiv', 'rpow', 'rmod', 'div', 'rdiv', 'eq', 'ne', 'lt']\n",
+      "['gt', 'le', 'ge', 'multiply', 'subtract', 'divide']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "DateOffset <class 'pandas._libs.tslibs.offsets.DateOffset'>\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "DatetimeIndex <class 'pandas.core.indexes.datetimes.DatetimeIndex'>\n",
+      "['strftime', 'tz_convert', 'tz_localize', 'to_period', 'to_julian_date', 'isocalendar', 'snap', 'get_loc', 'slice_indexer', 'indexer_at_time']\n",
+      "['indexer_between_time', 'to_pydatetime', 'std', 'normalize', 'round', 'floor', 'ceil', 'month_name', 'day_name', 'as_unit']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "DatetimeTZDtype <class 'pandas.core.dtypes.dtypes.DatetimeTZDtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "ExcelFile <class 'pandas.io.excel._base.ExcelFile'>\n",
+      "['ODFReader', 'OpenpyxlReader', 'PyxlsbReader', 'XlrdReader', 'parse', 'close']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "ExcelWriter <class 'pandas.io.excel._base.ExcelWriter'>\n",
+      "['close']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Flags <class 'pandas.core.flags.Flags'>\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Float32Dtype <class 'pandas.core.arrays.floating.Float32Dtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Float64Dtype <class 'pandas.core.arrays.floating.Float64Dtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Grouper <class 'pandas.core.groupby.grouper.Grouper'>\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "HDFStore <class 'pandas.io.pytables.HDFStore'>\n",
+      "['keys', 'items', 'open', 'close', 'flush', 'get', 'select', 'select_as_coordinates', 'select_column', 'select_as_multiple']\n",
+      "['put', 'remove', 'append', 'append_to_multiple', 'create_table_index', 'groups', 'walk', 'get_node', 'get_storer', 'copy']\n",
+      "['info']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Index <class 'pandas.core.indexes.base.Index'>\n",
+      "['is_', 'ravel', 'view', 'astype', 'take', 'repeat', 'copy', 'format', 'to_flat_index', 'to_series']\n",
+      "['to_frame', 'set_names', 'rename', 'sortlevel', 'get_level_values', 'droplevel', 'is_boolean', 'is_integer', 'is_floating', 'is_numeric']\n",
+      "['is_object', 'is_categorical', 'is_interval', 'holds_integer', 'isna', 'isnull', 'notna', 'notnull', 'fillna', 'dropna']\n",
+      "['unique', 'drop_duplicates', 'duplicated', 'union', 'intersection', 'difference', 'symmetric_difference', 'get_loc', 'get_indexer', 'reindex']\n",
+      "['join', 'memory_usage', 'where', 'append', 'putmask', 'equals', 'identical', 'asof', 'asof_locs', 'sort_values']\n",
+      "['sort', 'shift', 'argsort', 'get_indexer_non_unique', 'get_indexer_for', 'groupby', 'map', 'isin', 'slice_indexer', 'get_slice_bound']\n",
+      "['slice_locs', 'delete', 'insert', 'drop', 'infer_objects', 'any', 'all', 'argmin', 'argmax', 'min']\n",
+      "['max']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Int16Dtype <class 'pandas.core.arrays.integer.Int16Dtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Int32Dtype <class 'pandas.core.arrays.integer.Int32Dtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Int64Dtype <class 'pandas.core.arrays.integer.Int64Dtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Int8Dtype <class 'pandas.core.arrays.integer.Int8Dtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Interval <class 'pandas._libs.interval.Interval'>\n",
+      "['overlaps']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "IntervalDtype <class 'pandas.core.dtypes.dtypes.IntervalDtype'>\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "IntervalIndex <class 'pandas.core.indexes.interval.IntervalIndex'>\n",
+      "['memory_usage', 'get_loc', 'get_indexer_non_unique', 'overlaps', 'contains', 'set_closed', 'to_tuples']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "MultiIndex <class 'pandas.core.indexes.multi.MultiIndex'>\n",
+      "['set_levels', 'set_codes', 'copy', 'view', 'memory_usage', 'format', 'duplicated', 'fillna', 'dropna', 'get_level_values']\n",
+      "['unique', 'to_frame', 'to_flat_index', 'remove_unused_levels', 'take', 'append', 'argsort', 'repeat', 'drop', 'swaplevel']\n",
+      "['reorder_levels', 'sortlevel', 'get_slice_bound', 'slice_locs', 'get_loc', 'get_loc_level', 'get_locs', 'truncate', 'equals', 'equal_levels']\n",
+      "['astype', 'putmask', 'insert', 'delete', 'isin', 'rename']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "NamedAgg <class 'pandas.core.groupby.generic.NamedAgg'>\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Period <class 'pandas._libs.tslibs.period.Period'>\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "PeriodDtype <class 'pandas.core.dtypes.dtypes.PeriodDtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "PeriodIndex <class 'pandas.core.indexes.period.PeriodIndex'>\n",
+      "['asfreq', 'to_timestamp', 'asof_locs', 'get_loc', 'shift', 'strftime']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "RangeIndex <class 'pandas.core.indexes.range.RangeIndex'>\n",
+      "['memory_usage', 'get_loc', 'tolist', 'copy', 'min', 'max', 'argsort', 'factorize', 'equals', 'sort_values']\n",
+      "['symmetric_difference', 'delete', 'insert', 'all', 'any']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Series <class 'pandas.core.series.Series'>\n",
+      "['ravel', 'view', 'take', 'repeat', 'reset_index', 'to_string', 'to_markdown', 'items', 'keys', 'to_dict']\n",
+      "['to_frame', 'groupby', 'count', 'mode', 'unique', 'drop_duplicates', 'duplicated', 'idxmin', 'idxmax', 'round']\n",
+      "['quantile', 'corr', 'cov', 'diff', 'autocorr', 'dot', 'searchsorted', 'compare', 'combine', 'combine_first']\n",
+      "['update', 'sort_values', 'sort_index', 'argsort', 'nlargest', 'nsmallest', 'swaplevel', 'reorder_levels', 'explode', 'unstack']\n",
+      "['map', 'aggregate', 'agg', 'any', 'transform', 'apply', 'align', 'rename', 'set_axis', 'reindex']\n",
+      "['rename_axis', 'drop', 'fillna', 'pop', 'replace', 'info', 'shift', 'memory_usage', 'isin', 'between']\n",
+      "['isna', 'isnull', 'notna', 'notnull', 'dropna', 'asfreq', 'resample', 'to_timestamp', 'to_period', 'ffill']\n",
+      "['bfill', 'clip', 'interpolate', 'where', 'mask', 'hist', 'all', 'sem', 'var', 'std']\n",
+      "['cummin', 'cummax', 'cumsum', 'cumprod', 'sum', 'prod', 'product', 'mean', 'skew', 'kurt']\n",
+      "['kurtosis', 'median', 'max', 'min', 'add', 'radd', 'sub', 'mul', 'truediv', 'floordiv']\n",
+      "['mod', 'pow', 'rmul', 'rsub', 'rtruediv', 'rfloordiv', 'rpow', 'rmod', 'div', 'rdiv']\n",
+      "['divmod', 'rdivmod', 'eq', 'ne', 'lt', 'gt', 'le', 'ge', 'multiply', 'subtract']\n",
+      "['divide']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "SparseDtype <class 'pandas.core.arrays.sparse.dtype.SparseDtype'>\n",
+      "['update_dtype']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "StringDtype <class 'pandas.core.arrays.string_.StringDtype'>\n",
+      "['construct_array_type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Timedelta <class 'pandas._libs.tslibs.timedeltas.Timedelta'>\n",
+      "['round', 'floor', 'ceil']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "TimedeltaIndex <class 'pandas.core.indexes.timedeltas.TimedeltaIndex'>\n",
+      "['get_loc', 'to_pytimedelta', 'sum', 'std', 'median', 'total_seconds', 'round', 'floor', 'ceil']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "Timestamp <class 'pandas._libs.tslibs.timestamps.Timestamp'>\n",
+      "['strftime', 'round', 'floor', 'ceil', 'tz_localize', 'tz_convert', 'astimezone', 'replace', 'to_julian_date', 'isoweekday']\n",
+      "['weekday']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "UInt16Dtype <class 'pandas.core.arrays.integer.UInt16Dtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "UInt32Dtype <class 'pandas.core.arrays.integer.UInt32Dtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "UInt64Dtype <class 'pandas.core.arrays.integer.UInt64Dtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "UInt8Dtype <class 'pandas.core.arrays.integer.UInt8Dtype'>\n",
+      "['type']\n",
+      "--------------------------------------------------------------------------------------------------\n",
+      "option_context <class 'pandas._config.config.option_context'>\n",
+      "--------------------------------------------------------------------------------------------------\n"
+     ]
+    }
+   ],
+   "source": [
+    "classes = inspect.getmembers(pd, inspect.isclass)\n",
+    "dash_line = '-'.join(\"\" for i in range(1,100))\n",
+    "chunk_size = 10\n",
+    "# Will print all the classes and its member funcitons\n",
+    "for name, cls in classes:\n",
+    "    print(name, cls)\n",
+    "    methods = [name for name, member in cls.__dict__.items() if callable(member)]\n",
+    "    usable_methods = [m for m in methods if m[:1] != '_']\n",
+    "    for i in range(0, len(usable_methods), chunk_size):\n",
+    "        print(usable_methods[i:i+chunk_size])\n",
+    "    print(dash_line)"
+   ]
+  },
+  {
+   "cell_type": "code",
+>>>>>>> c1b8b2d (changes from macbook)
    "execution_count": 8,
    "metadata": {},
    "outputs": [
@@ -306,7 +500,11 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
+<<<<<<< HEAD
    "version": "3.10.12"
+=======
+   "version": "3.11.4"
+>>>>>>> c1b8b2d (changes from macbook)
   },
   "orig_nbformat": 4
  },
diff --git a/test.ipynb b/test.ipynb
new file mode 100644
index 0000000..6cdb417
--- /dev/null
+++ b/test.ipynb
@@ -0,0 +1,105 @@
+{
+ "cells": [
+  {
+   "cell_type": "code",
+   "execution_count": 7,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "# Define BrokerAPI1 with its specific buy and sell methods\n",
+    "class BrokerAPI1:\n",
+    "    def buy(self, amount):\n",
+    "        print(f\"BrokerAPI1: Buying {amount} units.\")\n",
+    "        # Implement actual buy logic for BrokerAPI1\n",
+    "    \n",
+    "    def sell(self, amount):\n",
+    "        print(f\"BrokerAPI1: Selling {amount} units.\")\n",
+    "        # Implement actual sell logic for BrokerAPI1\n",
+    "\n",
+    "# Define BrokerAPI2 with its specific buy and sell methods\n",
+    "class BrokerAPI2:\n",
+    "    def buy(self, amount):\n",
+    "        print(f\"BrokerAPI2: Buying {amount} units.\")\n",
+    "        # Implement actual buy logic for BrokerAPI2\n",
+    "    \n",
+    "    def sell(self, amount):\n",
+    "        print(f\"BrokerAPI2: Selling {amount} units.\")\n",
+    "        # Implement actual sell logic for BrokerAPI2"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 8,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "# Define the BrokerSelector class\n",
+    "class BrokerSelector:\n",
+    "    def __init__(self, choice):\n",
+    "        if choice == 1:\n",
+    "            self.broker = BrokerAPI1()\n",
+    "        elif choice == 2:\n",
+    "            self.broker = BrokerAPI2()\n",
+    "        else:\n",
+    "            raise ValueError(\"Invalid choice. Choose 1 for BrokerAPI1 or 2 for BrokerAPI2.\")\n",
+    "    \n",
+    "    \"\"\"\n",
+    "    def buy(self, amount):\n",
+    "        self.broker.buy(amount)\n",
+    "    \n",
+    "    def sell(self, amount):\n",
+    "        self.broker.sell(amount)\n",
+    "    \"\"\""
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": 10,
+   "metadata": {},
+   "outputs": [
+    {
+     "name": "stdout",
+     "output_type": "stream",
+     "text": [
+      "BrokerAPI1: Buying 10 units.\n",
+      "BrokerAPI1: Selling 5 units.\n",
+      "BrokerAPI2: Buying 20 units.\n",
+      "BrokerAPI2: Selling 10 units.\n"
+     ]
+    }
+   ],
+   "source": [
+    "# Create a selector with choice 1\n",
+    "selector = BrokerSelector(1)\n",
+    "selector.broker.buy(10)  # Calls BrokerAPI1's buy method\n",
+    "selector.broker.sell(5)  # Calls BrokerAPI1's sell method\n",
+    "\n",
+    "# Create a selector with choice 2\n",
+    "selector = BrokerSelector(2)\n",
+    "selector.broker.buy(20)  # Calls BrokerAPI2's buy method\n",
+    "selector.broker.sell(10)  # Calls BrokerAPI2's sell method"
+   ]
+  }
+ ],
+ "metadata": {
+  "kernelspec": {
+   "display_name": "tradingproject",
+   "language": "python",
+   "name": "python3"
+  },
+  "language_info": {
+   "codemirror_mode": {
+    "name": "ipython",
+    "version": 3
+   },
+   "file_extension": ".py",
+   "mimetype": "text/x-python",
+   "name": "python",
+   "nbconvert_exporter": "python",
+   "pygments_lexer": "ipython3",
+   "version": "3.11.4"
+  }
+ },
+ "nbformat": 4,
+ "nbformat_minor": 2
+}
